<html lang="en-US">

<head>
    <meta charset="UTF-8" />
    <title>Canvas experiment</title>
    <script type="application/javascript">
        var mapSize = null;
        const spacing = 2.0;
        var cellSize = null;
        var host = 'ws://localhost:8090/websockets.php';
        var world = null;
        var ws = null;
        var responseSinceLastMessage = false;
        var messagesToSend = [];
        function connect() {
            console.log("Connecting");

            ws = new WebSocket(host);

            ws.onmessage = function (e) {
                const data = e.data;
                const replaced = e.data.replace(/\\"/gm, `"`);
                const substringed = replaced.substring(1, replaced.length - 1);
                world = JSON.parse(substringed);
                console.log(world);
                mapSize = world.map.length;
                const canvas = document.querySelector('canvas');
                draw(canvas);
                responseSinceLastMessage = true;
            };

            ws.onclose = function (e) {
                console.log('Socket is closed. Reconnect will be attempted in 1 second.', e.reason);
                setTimeout(function () {
                    connect();
                }, 1000);
            };

            ws.onerror = function (err) {
                console.error('Socket encountered error: ', err.message, 'Closing socket');
                ws.close();
            };
        }


        document.addEventListener("DOMContentLoaded", () => {
            connect();

            const canvas = document.querySelector('canvas');
            
            let selecting = false;
            let cell_on_mouse_down = null;

            canvas.addEventListener('mousedown', function(e) {
                if (e.button != 0) {
                    return;
                }
                let hitTest = pickCellAtCoordsInCanvas(e.clientX, e.clientY, canvas);
                if (hitTest.hit) {
                    cell_on_mouse_down = hitTest.cell;
                    changeCellState(hitTest.cell);
                    selecting = true;
                } else {
                    selecting = false;
                    cell_on_mouse_down = null;
                }
            });
            canvas.addEventListener('mouseup', function(e) {
                if (e.button == 2 && !selecting) {
                    const rect = canvas.getBoundingClientRect()
               
                    const clickX = (e.clientX - rect.left);
                    const clickY = (e.clientY - rect.top);
                    const playerCoords = worldSpaceToScreenSpace(world.player.pos);
                    // console.log(`Player: ${playerCoords.x}, ${playerCoords.y}`)
                    // console.log(`Click: ${clickX}, ${clickY}`)
                    let connectingLineX = clickX - playerCoords.x;
                    let connectingLineY = clickY - playerCoords.y;
                    const mag = Math.sqrt(Math.pow(connectingLineX, 2) + Math.pow(connectingLineY, 2));
                    let dirX = connectingLineX / mag;
                    let dirY = connectingLineY / mag;
                    console.log(`${dirX}, ${dirY}`);
                } else {
                    selecting = false;
                    let hitTest = pickCellAtCoordsInCanvas(e.clientX, e.clientY, canvas);
                    if (!hitTest.hit) return;
                }
            });
            canvas.addEventListener('mousemove', function(e) {
                if (!selecting) return;
                let hitTest = pickCellAtCoordsInCanvas(e.clientX, e.clientY, canvas);
                if (!hitTest.hit) return;
                if (cellsEqual(hitTest.cell, cell_on_mouse_down)) return;
                if (hitTest.cell.value != cell_on_mouse_down.value) return;
                changeCellState(hitTest.cell);
            });
        });
        function changeDirection(newDir) {
            //ws.send(JSON.stringify([newDir]));
        }
        function changeCellState(c) {
            if (world.map[c.x][c.y] == 0) {
                world.map[c.x][c.y] = 1;
            } else {
                world.map[c.x][c.y] = 0;
            }
            if (!messagesToSend.some(m => cellsEqual({ x: m.cellClicked.x, y: m.cellClicked.y }, c))) {
                messagesToSend.push({
                        cellClicked: {
                            x: c.x,
                            y: c.y,
                        }
                    });
            }
            if (responseSinceLastMessage) {
                responseSinceLastMessage = false;
                ws.send(JSON.stringify(messagesToSend));
                messagesToSend = [];
            }
        }

        function cellsEqual(a, b) {
            if (a === b) return true;
            return a.x === b.x && a.y === b.y; 
        }

        function pickCellAtCoordsInCanvas(x, y, canvas) {
            // render to an element selection canvas
            var selectCanvas = document.createElement('canvas');
            selectCanvas.width = canvas.width;
            selectCanvas.height = canvas.height;
            draw(selectCanvas, true)

            const ctx = selectCanvas.getContext("2d");
            
            const rect = canvas.getBoundingClientRect()

            const screenX = (x - rect.left);
            const screenY = (y - rect.top);

            var pixel = ctx.getImageData(screenX, screenY, 1, 1).data;
            const worldX = pixel[0];
            const worldY = pixel[1];
            const missCheck = pixel[2];
            if (missCheck != 1) {
                return { hit: false };
            }
            if (worldX >= mapSize || worldY >= mapSize) {
                return { hit: false }
            }
            return { hit: true, cell: { x: worldX, y: worldY, value: world.map[worldX][worldY] }};
        }
        function worldSpaceToScreenSpace(coords) {
            return { 
                x: coords.x * cellSize + (spacing * (coords.x - 0.5)),
                y: coords.y * cellSize + (spacing * (coords.y - 0.5))
            }
        }
        function canvas_arrow(context, fromx, fromy, tox, toy) {
            var headlen = 15; // length of head in pixels
            var dx = tox - fromx;
            var dy = toy - fromy;
            var angle = Math.atan2(dy, dx);
            context.moveTo(fromx, fromy);
            context.lineTo(tox, toy);
            context.lineTo(tox - headlen * Math.cos(angle - Math.PI / 6), toy - headlen * Math.sin(angle - Math.PI / 6));
            context.moveTo(tox, toy);
            context.lineTo(tox - headlen * Math.cos(angle + Math.PI / 6), toy - headlen * Math.sin(angle + Math.PI / 6));
        }
        function draw(canvas, drawCoordColors = false) {
            const ctx = canvas.getContext("2d");

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            ctx.fillStyle = "rgb(255, 255, 255)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.strokeRect(0, 0, canvas.width, canvas.height);

            // let dimensionDiff = canvas.width - canvas.height;
            // if (dimensionDiff > 0) {
            //     ctx.translate(dimensionDiff / 2.0, 0.0);
            // } else {
            //     ctx.translate(0.0, -dimensionDiff / 2.0);
            // }


            if (drawCoordColors) {
                ctx.imageSmoothingEnabled = false;
                ctx.fillStyle = "rgb(0, 0, 0)";
                ctx.fillRect(0, 0, canvas.width, canvas.height)
            } else {
                ctx.imageSmoothingEnabled = true;
            }
            let smallest_dimension = Math.min(canvas.width, canvas.height);
            cellSize = (smallest_dimension / mapSize) - spacing;
            for (let x = 0; x < world.map.length; x++) {
                for (let y = 0; y < world.map.length; y++) {
                    let cell = world.map[x][y];
                    if (!drawCoordColors) {
                        switch (cell) {
                            case 0:
                                ctx.fillStyle = "rgb(0, 0, 0)";
                                break;
                            case 1:
                                ctx.fillStyle = "rgb(200, 0, 0)";
                                break;
                        }
                    } else {
                        ctx.fillStyle = `rgb(${x}, ${y}, 1)`;
                    }
                    ctx.fillRect(x * (cellSize + spacing), y * (cellSize + spacing), cellSize, cellSize);
                }
            }

            if (drawCoordColors) return;

            const pos = worldSpaceToScreenSpace(world.player.pos);
            const dir = worldSpaceToScreenSpace(world.player.dir);
            ctx.translate(pos.x, pos.y);

            ctx.lineWidth = 4;
            ctx.strokeStyle = 'rgb(255, 0, 255)';
            ctx.beginPath();
            canvas_arrow(ctx, 0, 0, dir.x, dir.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'green';
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#003300';
            ctx.stroke();
            ctx.closePath();

            for (let i = 0; i < world.rays.length; i++) {
                let ray = world.rays[i];
                const start = worldSpaceToScreenSpace(ray.start);
                const end = worldSpaceToScreenSpace(ray.end);
                ctx.lineWidth = 2;
                ctx.strokeStyle = 'rgb(0, 0, 255)';
                ctx.beginPath();
                canvas_arrow(ctx, 0, 0, end.x, end.y);
                ctx.stroke();
            }

            ctx.restore();
        }
    </script>
</head>

<body oncontextmenu="return false;">
    <canvas id="canvas" width="1000" height="800"></canvas>
</body>

</html>